package driver

import (
	"image"
	"image/color"
	"image/draw"
	"log"
	"sync"

	"github.com/HFO4/gbc-in-cloud/util"
)

type StaticImage struct {
	// Origin pixel data generated by the emulator
	pixelsDirty *[160][144][3]uint8
	// clean pixels to be displayed
	pixelsClean    [160][144][3]uint8
	lastPixelsTidy [160][144]byte
	pixelLock      sync.RWMutex

	inputStatus *byte
	inputQueue  []*inputCommand
	queueLock   sync.Mutex
}

type inputCommand struct {
	button byte
	ttl    int //time to live
	issued bool
}

type pixelCluster struct {
	pixel    byte
	repindex uint8
	repcount uint8
}

func (s *StaticImage) InitStatus(b *byte) {
	s.inputStatus = b
}

func (s *StaticImage) UpdateInput() bool {
	s.queueLock.Lock()
	if len(s.inputQueue) == 0 {
		s.queueLock.Unlock()
		return false
	}
	newInput := s.inputQueue[0]
	if newInput.ttl > 0 {
		newInput.ttl--
	} else {
		s.inputQueue = s.inputQueue[1:]
	}
	s.queueLock.Unlock()

	statusCopy := *s.inputStatus
	if !newInput.issued {
		statusCopy = util.ClearBit(statusCopy, uint(newInput.button))
		newInput.issued = true
	} else {
		if newInput.ttl > 0 {
			return false
		} else {
			statusCopy = util.SetBit(statusCopy, uint(newInput.button))
		}
	}

	*s.inputStatus = statusCopy

	return true
}

func (s *StaticImage) NewInput(bytes []byte) {
	panic("implement me")
}

func (s *StaticImage) Init(pixels *[160][144][3]uint8, s2 string) {
	s.pixelsDirty = pixels
	log.Println("[Display] Initialize static image display")
}

func (s *StaticImage) Run(drawSignal chan bool, f func()) {
	for {
		// drawSignal was sent by the emulator
		<-drawSignal
		s.pixelLock.Lock()
		if s.pixelsDirty != nil {
			s.pixelsClean = *s.pixelsDirty
		}
		s.pixelLock.Unlock()
	}
}

// Render raw pixels into images
func (s *StaticImage) Render() *image.RGBA {
	scaleRatio := 4
	s.pixelLock.RLock()

	img := image.NewRGBA(image.Rect(0, 0, 160*scaleRatio, 144*scaleRatio))

	for y := 0; y < 144; y++ {
		for x := 0; x < 160; x++ {
			r, g, b := s.pixelsClean[x][y][0], s.pixelsClean[x][y][1], s.pixelsClean[x][y][2]
			var dot color.RGBA

			if r == 0xFF && g == 0xFF && b == 0xFF {
				dot.R = 0x9b
				dot.G = 0xbc
				dot.B = 0x0f
			} else if r == 0xCC && g == 0xCC && b == 0xCC {
				dot.R = 0x8b
				dot.G = 0xac
				dot.B = 0x0f
			} else if r == 0x77 && g == 0x77 && b == 0x77 {
				dot.R = 0x30
				dot.G = 0x62
				dot.B = 0x30
			} else {
				dot.R = 0x0f
				dot.G = 0x38
				dot.B = 0x0f
			}
			dot.A = 0xff

			pixelRect := image.Rect(x*scaleRatio, y*scaleRatio, (x+1)*scaleRatio, (y+1)*scaleRatio)
			draw.Draw(img, pixelRect, &image.Uniform{dot}, image.Point{}, draw.Src)

		}
	}
	s.pixelLock.RUnlock()

	return img
}

func (s *StaticImage) GetBitmap() ([][]byte, [160][144]byte) {
	s.pixelLock.RLock()
	screen := tidyPixels(s.pixelsClean)

	var retscreen [][]byte
	s.pixelLock.RUnlock()
	for linenum, line := range screen {
		lineClusters := getLineClusters(line[:])
		compressedLine := compressLine(line[:], lineClusters)
		retscreen = append(retscreen, append([]byte{byte(linenum) + 0x04}, compressedLine...))
	}
	return retscreen, screen
}

func (s *StaticImage) GetBitmapDelta(lastBitmap [160][144]byte) ([][]byte, [160][144]byte) {
	s.pixelLock.RLock()

	screen := tidyPixels(s.pixelsClean)
	var difscreen [][]byte
	for linenum, line := range screen {
		compressedDifline := []byte{byte(linenum) + 0x04}
		var difline []byte
		lastLine := lastBitmap[linenum]
		//0x00 - 0x03 regular pixel color value
		//0xFF no change in pixel value since last image
		//0x04 - 0xA3 line identifier
		//0xCx repeat the following byte x times
		//0xF0 start regular line without compression
		//0xF1 start compressed line
		//0xF2 0xXX repeat the following byte XX times
		//0xFD repeat until end of line
		//0xFE ignore line
		//replace equal values with 0xFF
		if line == lastLine {
			//difscreen = append(difscreen, append(compressedDifline, 0xFE))
			continue
		}
		for index, pixel := range line {
			if pixel == lastLine[index] {
				difline = append(difline, 0xFF)
			} else {
				difline = append(difline, pixel)
			}
		}
		//clustering
		clusters := getLineClusters(difline)
		compressedDifline = append(compressedDifline, compressLine(difline, clusters)...)
		// shift := func(slc []byte) (byte, []byte) {
		// 	if len(slc) == 1 {
		// 		return slc[0], []byte{}
		// 	}
		// 	return slc[0], slc[1:]
		// }
		// data := compressedDifline
		// var b byte
		// if b, data = shift(data); b != 0xFB {
		// 	//nop
		// }
		// y := 0
		// lastline := lastBitmap[linenum]
		// for len(data) > 0 {
		// 	var op byte
		// 	op, data = shift(data)
		// 	if op > 0x03 && op < 0xA5 {
		// 		y = 0
		// 	} else if op == 0xF0 {
		// 		for len(data) > 0 && (data[0] < 0x04 || data[0] == 0xFF) {
		// 			var pixel byte
		// 			pixel, data = shift(data)
		// 			if pixel != 0xFF {
		// 				lastline[y] = pixel
		// 			}
		// 		}
		// 	} else if op == 0xF1 {
		// 		for len(data) > 0 && (data[0] < 0x04 || data[0] > 0xA4) {
		// 			b, data = shift(data)
		// 			if b < 0x04 {
		// 				lastline[y] = b
		// 				y++
		// 			} else if b == 0xFF {
		// 				y++
		// 			} else if b == 0xF2 {
		// 				var rcount byte
		// 				var rpx byte
		// 				rcount, data = shift(data)
		// 				rpx, data = shift(data)
		// 				for i := 0; i <= int(rcount); i++ {
		// 					if rpx != 0xFF {
		// 						lastline[y] = rpx
		// 					}
		// 					y++
		// 				}
		// 			} else if b > 0xC0 && b < 0xD0 {
		// 				var rpx byte
		// 				rcount := b - 0xC0
		// 				rpx, data = shift(data)
		// 				for i := 0; i <= int(rcount); i++ {
		// 					if rpx != 0xFF {
		// 						lastline[y] = rpx
		// 					}
		// 					y++
		// 				}
		// 			} else if b == 0xFD {
		// 				var rpx byte
		// 				rpx, data = shift(data)
		// 				for ; y < 144; y++ {
		// 					if rpx != 0xFF {
		// 						lastline[y] = rpx
		// 					}
		// 				}
		// 			}
		// 		}
		// 	} else if op == 0xFE {
		// 		continue
		// 	}
		// }
		// var pixels [][3]int
		// if lastline != line {
		// 	for n, p := range line {
		// 		if lastline[n] != p { //pos ex act
		// 			pixels = append(pixels, [3]int{n, int(p), int(lastline[n])})
		// 		}
		// 	}
		// }
		difscreen = append(difscreen, compressedDifline)
	}
	s.pixelLock.RUnlock()
	s.lastPixelsTidy = screen
	return difscreen, screen
}

// Render raw pixels into images
func (s *StaticImage) EnqueueInput(button byte) {
	s.queueLock.Lock()
	s.inputQueue = append(s.inputQueue, &inputCommand{button, 3, false})
	s.queueLock.Unlock()
}

func tidyPixels(pixels [160][144][3]byte) [160][144]byte {
	var screen [160][144]byte
	for y := 0; y < 144; y++ {
		for x := 0; x < 160; x++ {
			r, g, b := pixels[x][y][0], pixels[x][y][1], pixels[x][y][2]
			var color byte

			if r == 0xFF && g == 0xFF && b == 0xFF {
				color = 0x00
			} else if r == 0xCC && g == 0xCC && b == 0xCC {
				color = 0x01
			} else if r == 0x77 && g == 0x77 && b == 0x77 {
				color = 0x02
			} else {
				color = 0x03
			}

			screen[x][y] = color
		}
	}
	return screen
}

func getLineClusters(line []byte) []pixelCluster {
	clusters := []pixelCluster{}
	var lastpixel byte
	var repcount uint8
	var repindex uint8
	for index, pixel := range line {
		if index == 0 {
			lastpixel = pixel
			continue
		}
		if repcount > 0 {
			if lastpixel == pixel {
				repcount++
				if index == len(line)-1 {
					if repcount > 1 {
						clusters = append(clusters, pixelCluster{lastpixel, repindex, repcount})
					}
				}
			} else {
				if repcount > 1 {
					clusters = append(clusters, pixelCluster{lastpixel, repindex, repcount})
				}
				repcount = 0
				lastpixel = pixel
			}
		} else {
			if lastpixel == pixel {
				repindex = uint8(index - 1) //-1 because the cluster starts at the first equal int
				repcount = 1
			} else {
				lastpixel = pixel
			}
		}
	}
	return clusters
}

func shiftPc(clusters []pixelCluster) (pixelCluster, []pixelCluster) {
	c := clusters[0]
	return c, clusters[1:]
}

func compressLine(origLine []byte, cl []pixelCluster) []byte {
	line := origLine[:]

	var cluster pixelCluster
	var cline []byte
	clusters := cl
	hasClusters := len(clusters) > 0
	if !hasClusters {
		cline = append([]byte{0xF0}, line...)
	}
	for len(clusters) > 0 {
		cluster, clusters = shiftPc(clusters)
		i := cluster.repindex
		clend := i + cluster.repcount
		if clend >= 143 {
			line[i] = 0xFD
			i += 2
		} else if cluster.repcount < 16 {
			line[i] = 0xC0 + cluster.repcount
			i += 2
		} else {
			line[i] = 0xF2
			i++
			line[i] = cluster.repcount
			i += 2
		}
		for ; i <= clend; i++ {
			line[i] = 0xEE //trim
		}
		cline = []byte{0xF1}
	}
	if hasClusters {
		for _, px := range line {
			if px != 0xEE {
				cline = append(cline, px)
			}
		}
	}
	return cline
}

func XcompressLine(line []byte, clusters []pixelCluster) []byte {
	compressedLine := []byte{}
	if len(clusters) > 0 {
		compressedLine = append(compressedLine, 0xF1)
		var cluster pixelCluster
		cluster = clusters[0]
		clusters = clusters[1:]
		nextindex := -1
		for index, pixel := range line {
			if nextindex > 0 && index < nextindex {
				continue
			} else if cluster.repindex > uint8(index) {
				compressedLine = append(compressedLine, pixel)
				nextindex = -1
			} else {
				if (len(line)-1)-index > int(cluster.repcount) {
					if cluster.repcount < 16 {
						compressedLine = append(compressedLine, 0xC0+cluster.repcount)
						compressedLine = append(compressedLine, cluster.pixel)
					} else {
						compressedLine = append(compressedLine, 0xF2)
						compressedLine = append(compressedLine, cluster.repcount)
						compressedLine = append(compressedLine, cluster.pixel)
					}
				} else {
					compressedLine = append(compressedLine, 0xFD)
					compressedLine = append(compressedLine, cluster.pixel)
					break
				}
				nextindex = index + int(cluster.repcount) + 1
				if len(clusters) > 0 {
					cluster = clusters[0]
					clusters = clusters[1:]
				} else {
					break
				}
			}
		}
	} else {
		compressedLine = append(compressedLine, 0xF0)
		compressedLine = append(compressedLine, line...)
	}
	return compressedLine
}
