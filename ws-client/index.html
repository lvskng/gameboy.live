<!DOCTYPE html>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name='viewport' content='viewport-fit=cover, width=device-width, initial-scale=1.0, maximum-scale=1.0'>
<html>

<head>
  <title>{{.GameName}}</title>
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.{{.DebugMin}}js"></script>
</head>

<body scroll="no">
  <div id="app">
    <div id="emulator">
      <canvas id="emulatorScreen" @click="toggleSettings"></canvas>
      <div id="onScreenControls" v-if="!hideControls">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"
          viewBox="0 0 20.025 19.866000000000003" version="1.1" xml:space="preserve" id="dpad" class="onScreenInput"
          @pointerdown="handleDpadTouchStart" @pointermove="handleDpadTouchMove" @pointerup="handleDpadTouchEnd"
          @pointercancel="handleDpadTouchEnd">
          <defs>
            <linearGradient id="SVGID_1_" x1="0.5" x2="0.5" y1="1" y2="0">
              <stop offset="0.3" stop-color="#1E1E1E" />
              <stop offset="1" stop-color="#5B5B5F" />
            </linearGradient>
            <linearGradient id="SVGID_2_" x1="0.5" x2="0.5" y1="1" y2="0">
              <stop offset="0" stop-color="#141414" />
              <stop offset="0.23" stop-color="#181818" />
              <stop offset="0.46" stop-color="#242425" />
              <stop offset="0.7" stop-color="#373739" />
              <stop offset="0.94" stop-color="#535356" />
              <stop offset="1" stop-color="#5B5B5F" />
            </linearGradient>
            <linearGradient id="SVGID_3_" x1="0.5" x2="0.5" y1="1" y2="0">
              <stop offset="0.3" stop-color="#1E1E1E" />
              <stop offset="1" stop-color="#5B5B5F" />
            </linearGradient>
            <linearGradient id="SVGID_4_" x1="0.5" x2="0.5" y1="1" y2="0">
              <stop offset="0" stop-color="#141414" />
              <stop offset="0.23" stop-color="#181818" />
              <stop offset="0.46" stop-color="#242425" />
              <stop offset="0.7" stop-color="#373739" />
              <stop offset="0.94" stop-color="#535356" />
              <stop offset="1" stop-color="#5B5B5F" />
            </linearGradient>
            <linearGradient id="SVGID_5_" x1="0.5" x2="0.5" y1="1" y2="0">
              <stop offset="0.3" stop-color="#1E1E1E" />
              <stop offset="1" stop-color="#5B5B5F" />
            </linearGradient>
            <linearGradient id="SVGID_6_" x1="0.5" x2="0.5" y1="1" y2="0">
              <stop offset="0" stop-color="#141414" />
              <stop offset="0.23" stop-color="#181818" />
              <stop offset="0.47" stop-color="#242425" />
              <stop offset="0.72" stop-color="#373739" />
              <stop offset="0.96" stop-color="#525256" />
              <stop offset="1" stop-color="#57575B" />
            </linearGradient>
            <linearGradient id="SVGID_7_" x1="0.5" x2="0.5" y1="1" y2="0">
              <stop offset="0.3" stop-color="#1E1E1E" />
              <stop offset="1" stop-color="#5B5B5F" />
            </linearGradient>
            <linearGradient id="SVGID_8_" x1="0.5" x2="0.5" y1="1" y2="0">
              <stop offset="0" stop-color="#141414" />
              <stop offset="0.23" stop-color="#181818" />
              <stop offset="0.46" stop-color="#242425" />
              <stop offset="0.7" stop-color="#373739" />
              <stop offset="0.94" stop-color="#535356" />
              <stop offset="1" stop-color="#5B5B5F" />
            </linearGradient>
          </defs>
          <g class="layer">
            <title>D-Pad</title>
            <g id="svg_1">
              <g id="svg_2">
                <path class="dpad_btn"
                  d="m13.35,5.48l-3.34,2.97l-3.33,-2.97l0,-4.44c0,-0.62 0.5,-1.12 1.11,-1.12l4.44,0c0.62,0 1.12,0.5 1.12,1.11l0,4.45z"
                  fill="url(#SVGID_1_)" id="dpad_up" />
                <path
                  d="m12.23,0.57c0.26,0 0.47,0.21 0.47,0.46l0,4.16l-2.69,2.39l-2.68,-2.39l0,-4.15c0,-0.26 0.21,-0.47 0.46,-0.47l4.44,0m0,-0.65l-4.44,0c-0.61,0 -1.11,0.5 -1.11,1.11l0,4.45l3.33,2.97l3.34,-2.97l0,-4.44c0,-0.62 -0.5,-1.12 -1.12,-1.12l0,0z"
                  fill="url(#SVGID_2_)" id="svg_4" />
              </g>
              <g id="svg_5">
                <path class="dpad_btn"
                  d="m6.68,14.31l3.33,-2.98l3.34,2.98l0,4.44c0,0.62 -0.5,1.12 -1.12,1.12l-4.44,0c-0.61,0 -1.11,-0.5 -1.11,-1.12l0,-4.44z"
                  fill="url(#SVGID_3_)" id="dpad_down" />
                <path
                  d="m10.01,12.21l2.69,2.39l0,4.15c0,0.26 -0.21,0.47 -0.47,0.47l-4.44,0c-0.25,0 -0.46,-0.21 -0.46,-0.47l0,-4.15l2.68,-2.39m0,-0.87l-3.33,2.97l0,4.44c0,0.62 0.5,1.12 1.11,1.12l4.44,0c0.62,0 1.12,-0.5 1.12,-1.12l0,-4.44l-3.34,-2.97l0,0z"
                  fill="url(#SVGID_4_)" id="svg_7" />
              </g>
              <g>
                <path class="dpad_btn"
                  d="m14.47,13.27l-2.98,-3.34l2.98,-3.33l4.44,0c0.62,0 1.11,0.5 1.11,1.11l0,4.44c0,0.62 -0.5,1.12 -1.11,1.12l-4.44,0z"
                  fill="url(#SVGID_5_)" id="dpad_right" />
                <path
                  d="m18.91,7.25c0.26,0 0.47,0.21 0.47,0.46l0,4.44c0,0.26 -0.21,0.47 -0.47,0.47l-4.15,0l-2.39,-2.69l2.39,-2.68l4.15,0m0,-0.65l-4.44,0l-2.98,3.33l2.98,3.34l4.44,0c0.61,0 1.11,-0.5 1.11,-1.12l0,-4.44c0,-0.61 -0.49,-1.11 -1.11,-1.11l0,0z"
                  fill="url(#SVGID_6_)" id="svg_10" />
              </g>
              <g>
                <path class="dpad_btn"
                  d="m5.56,6.6l2.97,3.33l-2.97,3.34l-4.44,0c-0.62,0 -1.12,-0.5 -1.12,-1.12l0,-4.44c0,-0.61 0.5,-1.11 1.11,-1.11l4.45,0z"
                  fill="url(#SVGID_7_)" id="dpad_left" />
                <path
                  d="m5.27,7.25l2.39,2.68l-2.39,2.69l-4.15,0c-0.26,0 -0.47,-0.21 -0.47,-0.47l0,-4.44c0,-0.25 0.21,-0.46 0.47,-0.46l4.15,0m0.29,-0.65l-4.44,0c-0.62,0 -1.12,0.5 -1.12,1.11l0,4.44c0,0.62 0.5,1.12 1.11,1.12l4.45,0l2.97,-3.34l-2.97,-3.33l0,0z"
                  fill="url(#SVGID_8_)" id="svg_13" />
              </g>
            </g>
          </g>
        </svg>
        <img src="btn_start.svg" id="btn-start" @pointerdown="handleButtonTouchBegin" @pointerup="handleButtonTouchEnd"
          @pointercancel="handleButtonTouchEnd" class="onScreenInput btn-start" />
        <img src="btn_select.svg" id="btn-select" @pointerdown="handleButtonTouchBegin"
          @pointerup="handleButtonTouchEnd" @pointercancel="handleButtonTouchEnd" class="onScreenInput btn-select" />
        <img src="btn_a.svg" id="btn-a" @pointerdown="handleButtonTouchBegin" @pointerup="handleButtonTouchEnd"
          @pointercancel="handleButtonTouchEnd" class="onScreenInput btn-a" />
        <img src="btn_b.svg" id="btn-b" @pointerdown="handleButtonTouchBegin" @pointerup="handleButtonTouchEnd"
          @pointercancel="handleButtonTouchEnd" class="onScreenInput btn-b" />
      </div>
    </div>
    <div class="settings-menu" v-if="showSettings" @click.self="toggleSettings(false)">
      <div class="settings-content">
        <h2>Settings</h2>
        <div class="setting">
          <label><input type="checkbox" v-model="hideControls" @change="toggleFullscreen($event)"> Hide On-Screen
            Controls</label>
        </div>
        <div class="setting">
          <h3>Change Pixel Colors:</h3>
          <div v-for="(color, index) in getColors()" :key="index" class="color-picker">
            <input type="color" :value="color" @change="updateColors(index, $event.target.value)">
          </div>
          Opacity: <input type="number" v-model="opacity" @change="updateOpacity" min="0" max="255">
          <br />
          <button @click="resetColors()">Reset</button>
        </div>
        <div class="setting">
          <h3>Keyboard Bindings:</h3>
          <div v-for="(key, action) in keyboardMappings" :key="action" class="key-binding">
            <label>{{"{{ getGBKeyForScancode(key) }}"}}:</label>
            <select @change="updateKeyBindings(key, action, $event.target.value)">
              <option v-for="(code, index) in scanCodes" :value="code" :key="index" :selected="code == action">
                {{"{{code}}"}}</option>
            </select>
          </div>
          <button @click="resetKeys()">Reset</button>
        </div>
        <br />
        <button @click="toggleSettings(false)">Close</button>
      </div>
    </div>
  </div>
</body>
<script>
  function Mutex() {
    let current = Promise.resolve();
    this.lock = () => {
      let _resolve;
      const p = new Promise(resolve => {
        _resolve = () => resolve();
      });
      // Caller gets a promise that resolves when the current outstanding
      // lock resolves
      const rv = current.then(() => _resolve);
      // Don't allow the next request until the new promise is done
      current = p;
      // Return the new promise
      return rv;
    };
  }

  new Vue({
    name: 'App',
    data: () => {
      return {
        wsConn: new WebSocket("{{.WebSocketUrl}}"),
        input: '',
        currentBtnPress: '',
        lastButtonPress: '',
        dpadPointerDown: false,
        buttonPressCount: 0,
        emulatorScreen: [],
        showSettings: false,
        hideControls: false,
        keys: {
          UP: 2,
          DOWN: 3,
          LEFT: 1,
          RIGHT: 0,
          A: 4,
          B: 5,
          START: 7,
          SELECT: 6,
        },
        pressedKeys: {
          0: false,
          1: false,
          2: false,
          3: false,
          4: false,
          5: false,
          6: false,
          7: false
        },
        keyboardMappings: {
          ArrowRight: 0,
          ArrowLeft: 1,
          ArrowUp: 2,
          ArrowDown: 3,
          KeyZ: 4,
          KeyX: 5,
          Space: 7,
          ShiftRight: 6
        },
        lastInput: 0,
        lastDpadDown: 0,
        dpadKeyDown: false,
        opacity: 0xFF,
        colors: [[0x9b, 0xbc, 0x0f, 0xff], [0x8b, 0xac, 0x0f, 0xff], [0x30, 0x62, 0x30, 0xff], [0x0f, 0x38, 0x0f, 0xff]],
        scanCodes: [ //All possible keyboard scan codes in JS
          "Backspace",
          "Tab",
          "Enter",
          "ShiftLeft",
          "ShiftRight",
          "ControlLeft",
          "ControlRight",
          "AltLeft",
          "AltRight",
          "Pause",
          "CapsLock",
          "Escape",
          "Space",
          "PageUp",
          "PageDown",
          "End",
          "Home",
          "ArrowLeft",
          "ArrowUp",
          "ArrowRight",
          "ArrowDown",
          "PrintScreen",
          "Insert",
          "Delete",
          "Digit0",
          "Digit1",
          "Digit2",
          "Digit3",
          "Digit4",
          "Digit5",
          "Digit6",
          "Digit7",
          "Digit8",
          "Digit9",
          "KeyA",
          "KeyB",
          "KeyC",
          "KeyD",
          "KeyE",
          "KeyF",
          "KeyG",
          "KeyH",
          "KeyI",
          "KeyJ",
          "KeyK",
          "KeyL",
          "KeyM",
          "KeyN",
          "KeyO",
          "KeyP",
          "KeyQ",
          "KeyR",
          "KeyS",
          "KeyT",
          "KeyU",
          "KeyV",
          "KeyW",
          "KeyX",
          "KeyY",
          "KeyZ",
          "MetaLeft",
          "MetaRight",
          "ContextMenu",
          "Numpad0",
          "Numpad1",
          "Numpad2",
          "Numpad3",
          "Numpad4",
          "Numpad5",
          "Numpad6",
          "Numpad7",
          "Numpad8",
          "Numpad9",
          "NumpadMultiply",
          "NumpadAdd",
          "NumpadSubtract",
          "NumpadDecimal",
          "NumpadDivide",
          "F1",
          "F2",
          "F3",
          "F4",
          "F5",
          "F6",
          "F7",
          "F8",
          "F9",
          "F10",
          "F11",
          "F12",
          "NumLock",
          "ScrollLock",
          "Semicolon",
          "Equal",
          "Comma",
          "Minus",
          "Period",
          "Slash",
          "Backquote",
          "BracketLeft",
          "Backslash",
          "BracketRight",
          "Quote"
        ],
        inputLock: new Mutex(),
        drawingCanvasLock: new Mutex(),
      }
    },
    methods: {
      toggleSettings(value) {
        this.showSettings = value;
        if (!value) {
          this.saveSettingsToCookie()
        }
      },
      toggleFullscreen(event) {
        document.getElementById("emulatorScreen").style.height = event.srcElement.checked ? "100vh" : "auto"
      },
      getColors() {
        ret = []
        for (const color of this.colors) {
          const [r, g, b, a] = color
          ret.push(`#${r > 15 ? "" : "0"}${r.toString(16)}${g > 15 ? "" : "0"}${g.toString(16)}${b > 15 ? "" : "0"}${b.toString(16)}`)
        }
        return ret
      },
      updateColors(index, color) {
        let col = []
        color = color.substring(1) //remove #
        for (i = 0; i < 3; i++) {
          col[i] = parseInt(`${color[0] + color[1]}`, 16)
          color = color.substring(2)
        }
        col[3] = this.opacity
        Vue.set(this.colors, index, col);
      },
      updateOpacity() {
        let newColors = []
        for (const color of this.colors) {
          newColors.push([color[0], color[1], color[2], this.opacity])
        }
        this.colors = newColors
      },
      resetColors() {
        this.opacity = 0xFF
        this.colors = [[0x9b, 0xbc, 0x0f, 0xff], [0x8b, 0xac, 0x0f, 0xff], [0x30, 0x62, 0x30, 0xff], [0x0f, 0x38, 0x0f, 0xff]]
      },
      updateKeyBindings(gbKey, oldKey, newKey) {
        Vue.delete(this.keyboardMappings, oldKey)
        Vue.set(this.keyboardMappings, newKey, gbKey)
      },
      getGBKeyForScancode(scancode) {
        for (const [index, key] of Object.entries(this.keys)) {
          if (key == scancode) return index
        }
      },
      resetKeys() {
        this.keyboardMappings = {
          ArrowRight: 0,
          ArrowLeft: 1,
          ArrowUp: 2,
          ArrowDown: 3,
          KeyZ: 4,
          KeyX: 5,
          Space: 7,
          ShiftRight: 6
        }
      },
      async pressKey(event) {
        if (event.code == "F3") {
          var dataURL = document.getElementById("emulatorScreen").toDataURL("image/png");
          var newTab = window.open('about:blank', 'image from canvas');
          newTab.document.write("<img src='" + dataURL + "' alt='from canvas'/>");
          return;
        }
        let key = this.keyboardMappings[event.code]
        if (key != undefined) {
          const unlock = await this.inputLock.lock()
          this.pressedKeys[key] = true
          if (key < 4) this.dpadKeyDown = true
          unlock()
        }
      },
      async releaseKey(event) {
        let key = this.keyboardMappings[event.code]
        if (key != undefined) {
          const unlock = await this.inputLock.lock()
          this.pressedKeys[key] = false
          unlock()
        }
      },
      handleDpadTouchStart(event) {
        event.preventDefault();
        let elem = document.elementFromPoint(event.clientX, event.clientY)
        if (!elem) {
          this.setDpad(4)
        }
        this.dpadPointerDown = true
        let id = elem.id
        if (![...elem.classList].includes("dpad_btn")) return
        let dir = this.getDpadButtonFromId(id)
        if (dir != undefined) {
          this.setDpad(this.keys[dir])
        }
      },
      handleDpadTouchMove(event) {
        event.preventDefault()
        let elem = document.elementFromPoint(event.clientX, event.clientY)
        let id = elem.id
        if (![...elem.classList].includes("dpad_btn")) return
        let dir = this.getDpadButtonFromId(id)
        if (!this.dpadPointerDown) {
          this.setDpad(4)
          return
        }
        if (!elem) {
          this.setDpad(4)
        }

        if (dir != undefined) {
          this.setDpad(this.keys[dir])
        }
      },
      handleDpadTouchEnd(event) {
        event.preventDefault()
        this.dpadPointerDown = false
        this.setDpad(4)
      },
      getDpadButtonFromId(id) {
        switch (id) {
          case "dpad_up":
            return "UP"
          case "dpad_down":
            return "DOWN"
          case "dpad_left":
            return "LEFT"
          case "dpad_right":
            return "RIGHT"
        }
      },
      handleButtonTouchBegin(event) {
        event.preventDefault();
        let elem = document.elementFromPoint(event.clientX, event.clientY)
        let id = elem.id
        this.currentBtnPress = id.replace("btn-", '').toUpperCase()
        this.pressedKeys[this.keys[id.replace("btn-", '').toUpperCase()]] = true
      },
      handleButtonTouchEnd(event) {
        event.preventDefault()
        this.currentBtnPress = ''
        let elem = document.elementFromPoint(event.clientX, event.clientY)
        let id = elem.id
        this.pressedKeys[this.keys[id.replace("btn-", '').toUpperCase()]] = false
      },
      setDpad(dir) {
        for (const key of Object.keys(this.pressedKeys)) {
          if (key < 4) {
            if (key == dir) this.pressedKeys[key] = true
            else this.pressedKeys[key] = false
          } else break
        }
      },
      saveSettingsToCookie() {
        const settings = {
          hideControls: this.hideControls,
          opacity: this.opacity,
          colors: this.colors,
          keyboardMappings: this.keyboardMappings,
        };
        const settingsString = JSON.stringify(settings);
        const d = new Date();
        d.setTime(d.getTime() + (365 * 24 * 60 * 60 * 1000)); // 1 year expiration
        const expires = "expires=" + d.toUTCString();
        document.cookie = "gameSettings=" + settingsString + ";" + expires + ";path=/";
      },

      loadSettingsFromCookie() {
        const name = "gameSettings=";
        const decodedCookie = decodeURIComponent(document.cookie);
        const ca = decodedCookie.split(';');
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) == ' ') {
            c = c.substring(1);
          }
          if (c.indexOf(name) == 0) {
            const settingsString = c.substring(name.length, c.length);
            const settings = JSON.parse(settingsString);
            this.hideControls = settings.hideControls;
            this.opacity = settings.opacity;
            this.colors = settings.colors;
            this.keyboardMappings = settings.keyboardMappings;
            return;
          }
        }
      },
      },
      created() {

      },
      mounted() {
        const drawingCanvas = document.createElement("canvas")
        const canvas = document.getElementById("emulatorScreen")
        const ctx = canvas.getContext("2d")
        const drawingCtx = drawingCanvas.getContext("2d")

        this.loadSettingsFromCookie()
        canvas.style.height = this.hideControls ? "100vh" : "auto"

        let restoreConn = event => {
          setTimeout(() => {
            if (document.hasFocus && !this.wsConn || this.wsConn.readyState == 3) {
              this.wsConn = new WebSocket("{{.WebSocketUrl}}")
              this.wsConn.onmessage = receiveBitmap
              this.wsConn.onclose = restoreConn
            }
          }, "3000");
        }

        this.wsConn.onclose = restoreConn

        document.onfocus = () => {
          if (this.wsConn.readyState != WebSocket.OPEN) {
            restoreConn()
          }
        }

        const originalWidth = 160
        const originalHeight = 144
        drawingCanvas.width = originalWidth
        drawingCanvas.height = originalHeight

        let drawScreen = async () => {
          const unlock = await this.drawingCanvasLock.lock()
          ctx.drawImage(drawingCanvas, 0, 0, canvas.width, canvas.height)
          unlock()
          window.requestAnimationFrame(drawScreen)
        }
        window.requestAnimationFrame(drawScreen)

        let drawPixel = (x, y, color) => {
          const newColor = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`
          drawingCtx.fillStyle = newColor
          drawingCtx.fillRect(x, y, 1, 1)
        }

        let receiveBitmap = event => {
          event.data.arrayBuffer().then(async buf => {
            const unlock = await this.drawingCanvasLock.lock()
            let data = new Uint8Array(buf)
            let dataIndex = 0
            let shiftData = () => {
              let r = data[0]
              data = data.subarray(1)
              return r
            }
            const difMode = shiftData() == 0xFB
            if (!difMode) {
              drawingCtx.clearRect(0, 0, canvas.width, canvas.height)
            }
            let x = 0
            let y = 0
            while (data.length > 0) {
              const op = shiftData()
              if (op > 0x03 && op < 0xA5) {
                //vertical line index
                x = op - 4
                y = 0
              }
              else if (op == 0xF0) {
                do {
                  let pixel = shiftData()
                  if (pixel != 0xFF) drawPixel(x, y, this.colors[pixel])
                  y++
                } while (data[0] < 0x04 || data[0] == 0xFF)
              }
              else if (op == 0xF1) {
                do {
                  let pixel = shiftData()
                  if (pixel < 0x04) {
                    drawPixel(x, y, this.colors[pixel])
                    y++
                  }
                  else if (pixel == 0xFF) {
                    y++
                  }
                  else if (pixel == 0xF2) {
                    //repeat byte XX times
                    let rcount = shiftData()
                    let rpixel = shiftData()
                    for (let i = 0; i <= rcount; i++) {
                      if (rpixel != 0xFF) drawPixel(x, y, this.colors[rpixel])
                      y++
                    }
                  }
                  else if (pixel > 0xC0 && pixel < 0xD0) {
                    //repeat byte X times
                    let rcount = pixel - 0xC0
                    let rpixel = shiftData()
                    for (let i = 0; i <= rcount; i++) {
                      if (rpixel != 0xFF) drawPixel(x, y, this.colors[rpixel])
                      y++
                    }
                  }
                  else if (pixel == 0xFD) {
                    let rpixel = shiftData()
                    for (; y < 144; y++) {
                      if (rpixel != 0xFF) drawPixel(x, y, this.colors[rpixel])
                    }
                  }
                } while (data[0] < 0x04 || data[0] > 0xA4)
              }
              else if (op == 0xFE) {
                continue
              }
            }
            unlock()
          })
        }

        this.wsConn.onmessage = receiveBitmap

        window.addEventListener("keydown", this.pressKey.bind(this))
        window.addEventListener("keyup", this.releaseKey.bind(this))
        canvas.width = originalWidth;
        canvas.height = originalHeight;

        this.wsConn.addEventListener("open", event => {
          let clearBit = (byte, bit) => {
            return byte & ~(1 << bit);
          }
          window.setInterval(async () => {
            let input = 0xFF
            const unlock = await this.inputLock.lock()
            for (const [key, val] of Object.entries(this.pressedKeys)) {
              if (val === true) {
                if (key > 3 || (this.dpadPointerDown || this.dpadKeyDown)) input = clearBit(input, key)
              }
            }
            unlock()
            if (input != 0xFF || input != this.lastInput) {
              let buf = new ArrayBuffer(1)
              const v = new DataView(buf)
              v.setUint8(0, input)
              this.wsConn.send(buf)
            }
            this.lastInput = input
          }, 100)
        })

        let preventZoom = function (e) {
          var t2 = e.timeStamp;
          var t1 = e.currentTarget.dataset.lastTouch || t2;
          var dt = t2 - t1;
          var fingers = e.touches.length;
          e.currentTarget.dataset.lastTouch = t2;

          if (!dt || dt > 500 || fingers > 1) return; // not double-tap

          e.preventDefault();
          e.target.click();
        }

        Object.entries(document.getElementsByClassName("onScreenInput")).forEach(arr => {
          let btn = arr[1]
          btn.addEventListener('touchstart', preventZoom)
        })
      }
    }).$mount('#app')
</script>
</body>

<style>
  #emulator {
    height: 100vh;
    display: inline-block;
  }

  #emulatorScreen {
    display: block;
    width: 100%;
    height: auto;
    margin: 0;
    image-rendering: pixelated;
    aspect-ratio: 160/144;
  }

  #onScreenControls {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr 1fr;
    grid-template-areas:
      "dpad dpad . . . btn-a"
      "dpad dpad . . btn-b ."
      ". . btn-select btn-start . .";
    justify-content: center;
    align-items: center;
    width: 100%;
    gap: 10px;
    margin-top: 1em;
  }

  .btn-a,
  .btn-b {
    height: 10vh;
  }

  .btn-a {
    grid-area: btn-a;
  }

  .btn-b {
    grid-area: btn-b;
  }

  .btn-start,
  .btn-select {
    height: 3vh;
  }

  .btn-start {
    grid-area: btn-start;
  }

  .btn-select {
    grid-area: btn-select;
  }

  #dpad {
    grid-area: dpad;
    height: 20vh;
  }

  body,
  html {
    margin: 0;
    background-color: black;
    -webkit-user-select: none;
    /* Safari */
    -ms-user-select: none;
    /* IE 10 and IE 11 */
    height: 100vh;
    overflow: hidden;
    /* Prevent scrolling */
    touch-action: none;
    /* Disable zooming and long press events */
    display: flex;
    justify-content: center;
    align-items: center;
    -webkit-touch-callout: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    user-select: none;
    outline: none;
    overflow: hidden;
  }

  #btn-settings {
    display: block;
    height: 5vh;
  }

  .settings-menu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #fff;
    color: #000;
    padding: 20px;
    border-radius: 10px;
    z-index: 10;
  }
</style>

</html>